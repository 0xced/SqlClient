<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    
    <PropertyGroup>
	<ShipsInNETFramework Condition="'$(ShipsInNETFramework)' == ''">true</ShipsInNETFramework>
        <DllBaseLookupFileSufix></DllBaseLookupFileSufix>
        <DllBaseLookupFileSufix Condition="'$(BuildProjectName)' == 'CoreCLR'">$(DllBaseLookupFileSufix)core</DllBaseLookupFileSufix>
        <DllBaseLookupFileSufix Condition="'$(BuildProjectName)' == 'CoreSys'">$(DllBaseLookupFileSufix)coresys</DllBaseLookupFileSufix>
        <DllBaseLookupFileSufix Condition="'$(BuildType)' == 'Debug'">$(DllBaseLookupFileSufix)d</DllBaseLookupFileSufix>
        <DllBaseLookupFileSufix Condition="'$(BuildType)' == 'Checked'">$(DllBaseLookupFileSufix)c</DllBaseLookupFileSufix>

        <DllBaseLookupFile Condition="'$(DllBaseLookupFile)' == ''">$(InternalPath)\NDP\coffbase\$(BuildArchitecture)\coffbase$(DllBaseLookupFileSufix).txt</DllBaseLookupFile>
        <BinplaceSymbols Condition="'$(BinplaceSymbols)' == ''">true</BinplaceSymbols>
    </PropertyGroup>
    
    <ItemGroup>
        <BinplacePlacefile Include="$(_NTDRIVE)$(_NTROOT)\ndp\inc\obj$(DirectorySuffix)\$(BuildArchitecture)\placefil.txt" />
        <FileList Include="$(_NTDRIVE)$(_NTROOT)\tools\devdiv\batchsetup\filelist.xml" />
    </ItemGroup>

    <Import Project="$(_NTDRIVE)$(_NTROOT)\tools\Microsoft.DevDiv.targets" Condition="'$(ProjectLanguage)' != 'Native'" />
    <Import Project="$(_NTDRIVE)$(_NTROOT)\tools\Microsoft.DevDiv.native.targets" Condition="'$(ProjectLanguage)' == 'Native'" />

    <!-- 
        Many directories in the Ndp tree have their build process set up to build the assembly
        to the binaries directory.  Then, after the build is complete, the devs run the script
        in ndp\fx\tools\propvs.bat to propagate the assemblies/PDBs from the binaries directory
        to the binaries\bin\i386 directory, which is where VS actually expects to find them
        at run-time.  Here, we attempt to go ahead and copy the assembly to the final location
        in binaries\bin\i386 as part of the build process.  But if the copy fails because a running
        copy of VS has it locked, then don't fail the build.  Those devs will have to run propvs.bat
        after they shut down VS, which is the way they're accustomed to working.
    -->
    <PropertyGroup>
        <DevDivBuildDependsOn>$(DevDivBuildDependsOn);AttemptCopyAssemblyToVsDirectory</DevDivBuildDependsOn>
    </PropertyGroup>
    <Target 
        Name="AttemptCopyAssemblyToVsDirectory"
        Condition="'$(AttemptCopyAssemblyToVsDirectory)' == 'true'">

        <Exec 
            Command="
                copy &quot;@(IntermediateAssembly)&quot; &quot;$(BinariesDirectory)\bin\$(BuildArchitecture)&quot;
                if errorlevel 1 echo Microsoft.Ndp.targets : warning : @(IntermediateAssembly->'%(FileName)%(Extension)') could not be copied to &quot;$(BinariesDirectory)\bin\$(BuildArchitecture)&quot;, possibly because the destination file is locked by Devenv or some other process.  Please copy it manually or run ndp\fx\tools\propvs.bat after the build is complete.
                copy &quot;$(IntermediateOutputPath)$(TargetName).pdb&quot; &quot;$(BinariesDirectory)\bin\$(BuildArchitecture)&quot;
                if errorlevel 1 echo Microsoft.Ndp.targets : warning : $(TargetName).pdb could not be copied to &quot;$(BinariesDirectory)\bin\$(BuildArchitecture)&quot;, possibly because the destination file is locked by Devenv or some other process.  Please copy it manually or run ndp\fx\tools\propvs.bat after the build is complete.
                "
            IgnoreExitCode="true"/>

    </Target>

    <ItemGroup Condition="'$(UseCommonResourceStrings)' == 'true' and '$(ProjectLanguage)' == 'CSharp'">
        <EmbeddedResource Include="$(DevDivToolsPath)\CommonResStrings.txt">
           <LogicalName>CommonResStrings.resources</LogicalName>
           <Type>Resx</Type>
        </EmbeddedResource> 
      <ManagedPreprocessFile Include="$(DevDivToolsPath)\CommonResStrings.cspp" />  
    </ItemGroup>
    

    <!-- **************************************************************************************************** -->
    <!-- *** Add ndp\inc to CL Include Path                                                                   -->
    <!-- **************************************************************************************************** -->
    <PropertyGroup>
        <ClIncludePaths Condition="'$(UseVsVersion)' == 'false'">$(ClrIncPath);$(NDP_CommonIncPath);$(NdpRootIncPath);$(NdpRootIncPath)\version;$(ClIncludePaths)</ClIncludePaths>
    </PropertyGroup>

    <!--- *************************************************************************************************** -->
    <!--- ***    DevDiv MSBuild by default uses a couple placefiles in Tools and Tools\DevDiv.                -->
    <!--- ***    Capture our specific placefile settings by setting a custom placefile.                       -->
    <!--- ***    As with the DevDiv default, this generates the placefile into IntermediateOutputDirectory    -->
    <!--- ***    of each project compiled which is more work, but makes us compatible with read-only source   -->
    <!--- ***    when DDE throws the switch.                                                                  -->
    <!--- ***                                                                                                 -->
    <!--- ***    Opt into this by setting $(GeneratePlacefileFromFilelist) to true.                           -->
    <!--- *************************************************************************************************** -->

    <PropertyGroup Condition="'$(GeneratePlacefileFromFilelist)' == 'true'">
      <BinplacePlacefile>$(IntermediateOutputDirectory)\placefil.txt</BinplacePlacefile>
    </PropertyGroup>
    
    <PropertyGroup Condition="'$(BuildProjectName)' == ''">
      <PLACE_GROUP_NAME>Desktop</PLACE_GROUP_NAME>
    </PropertyGroup>
    <PropertyGroup Condition="'$(BuildProjectName)' != ''">
      <PLACE_GROUP_NAME>CoreCLR</PLACE_GROUP_NAME>
    </PropertyGroup>
    
    <Target Name="NdpGeneratePlaceFile"
            Condition="'$(GeneratePlacefileFromFilelist)' == 'true'"
            Inputs="@(FileList)"
            Outputs="$(BinplacePlacefile)"
            BeforeTargets="PlaceSymbols">

      <Exec Command="$(DevDivToolsPath)\genplacefile.bat $(BinplacePlacefile) @(FileList) $(PLACE_GROUP_NAME)" 
            StandardOutputImportance="Normal"/>
    </Target>

    <!--- *************************************************************************************************** -->

    <!--- *************************************************************************************************** -->


    <!-- ********************************************************************************************* -->
    <!-- *** Generate split debug resources from .txt format resource files                            -->
    <!-- ***                                                                                           -->
    <!-- *** This is similar is use to <TextStringResource> but different enough that it doesn't make  -->
    <!-- *** sense (in my opinion) to combine it with the existing task by adding extra metadata       -->
    <!-- ********************************************************************************************* -->
    <PropertyGroup>
        <GenerateSplitTextStringResourcesDependsOn>
         GenerateSplitStringResources;
         GenerateSplitStringResourcesClass;
         GenerateSplitParameterizedResourceClasses;
      </GenerateSplitTextStringResourcesDependsOn>
      <PreprocessDependsOn>$(PreprocessDependsOn);GenerateSplitTextStringResources</PreprocessDependsOn>
    </PropertyGroup>

    <Target Name="GenerateSplitTextStringResources"
            Condition="'@(SplitTextStringResource)' != ''"
            Outputs="$(IntermediateOutputDirectory)\%(SplitTextStringResource.Filename).resources"
            DependsOnTargets="$(GenerateSplitTextStringResourcesDependsOn)"/>

    <Target Name="GenerateSplitStringResources">
         
        <ItemGroup>
            <Internal_ResGenDefines Remove="" />
            <Internal_ResGenDefines Include="%(SplitTextStringResource.ResGenDefines)" />
        </ItemGroup>    

        <Exec Command="$(ResGenCommand) %(SplitTextStringResource.Identity) $(IntermediateOutputDirectory)\%(SplitTextStringResource.Filename).resources /D:INCLUDE_DEBUG /D:INCLUDE_RUNTIME @(Internal_ResGenDefines->'/D:%(Identity)', ' ')" />

        <ItemGroup>
            <EmbeddedResource Include="@(SplitTextStringResource->'$(IntermediateOutputDirectory)\%(Filename).resources')">
                <!-- "Resx" indicates it should go through GenerateResource -->
                <WithCulture>false</WithCulture>           
                <ManifestResourceName>%(Filename)</ManifestResourceName>
            </EmbeddedResource>
            <Clean Include="$(IntermediateOutputDirectory)\%(SplitTextStringResource.Filename).resources" />
        </ItemGroup>

        <ItemGroup>
            <Internal_ResGenDefines Remove="" />
        </ItemGroup> 

    </Target>

    <!-- ********************************************************************************************* -->

    <!-- ********************************************************************************************* -->
    <!-- *** Generate strongly typed resources -->
    <!-- ********************************************************************************************* -->
    <Target Name="GenerateSplitStringResourcesClass"
            Inputs="$(MSBuildAllProjects);@(SplitTextStringResource)"
            Outputs="@(SplitTextStringResource->'$(IntermediateOutputDirectory)\%(Filename).SplitResourceClass$(DefaultSourceExtension)pp')"
            Condition="'@(SplitTextStringResource)' != ''">

        <!-- We do not currently use GenerateResource task here because the GenSR script 
           generates a slightly different strongly typed resource code format -->

        <PropertyGroup>
            <GenSRKeyType Condition="'$(AssemblyKeyType)' == 'SILVERLIGHT_PLATFORM'">SILVERLIGHT_PLATFORM_PUBLICKEY_STR</GenSRKeyType>
            <GenSRKeyType Condition="'$(AssemblyKeyType)' != 'SILVERLIGHT_PLATFORM'">SILVERLIGHT_PUBLICKEY_STR</GenSRKeyType>
        </PropertyGroup>

        <!-- Sealed classes -->
        <Exec Command="$(SplitGenSRCommand) %(SplitTextStringResource.Identity) $(IntermediateOutputDirectory)\%(SplitTextStringResource.Filename).SplitResourceClass$(DefaultSourceExtension)pp %(SplitTextStringResource.FullClassName) %(SplitTextStringResource.ResFile) %(SplitTextStringResource.Visibility) $(GenSRKeyType) 1 -D %(SplitTextStringResource.GenSRDefines) INCLUDE_RUNTIME INCLUDE_DEBUG"
              StandardOutputImportance="Normal"
              Condition="'%(SplitTextStringResource.Sealed)' == 'true' and '%(SplitTextStringResource.FullClassName)' != '' and '%(SplitTextStringResource.NoStringResourcesClass)' != 'true'"/>

        <!-- Unsealed classes -->
        <Exec Command="$(SplitGenSRCommand) %(SplitTextStringResource.Identity) $(IntermediateOutputDirectory)\%(SplitTextStringResource.Filename).SplitResourceClass$(DefaultSourceExtension)pp %(SplitTextStringResource.FullClassName) %(SplitTextStringResource.ResFile) %(SplitTextStringResource.Visibility) $(GenSRKeyType) -D %(SplitTextStringResource.GenSRDefines) INCLUDE_RUNTIME INCLUDE_DEBUG"
              StandardOutputImportance="Normal"
              Condition="'%(SplitTextStringResource.Sealed)' != 'true' and '%(SplitTextStringResource.FullClassName)' != '' and '%(SplitTextStringResource.NoStringResourcesClass)' != 'true'"/>

        <!-- Generate the output items in an itemgroup, instead of using the output tag, so that metadata flows -->
        <ItemGroup>
            <ManagedPreprocessFile Include="@(SplitTextStringResource->'$(IntermediateOutputDirectory)\%(Filename).SplitResourceClass$(DefaultSourceExtension)pp')"
                                   Condition="'%(SplitTextStringResource.FullClassName)' != '' and '%(SplitTextStringResource.NoStringResourcesClass)' != 'true'">
                <Defines>SILVERLIGHT</Defines>
                <OutputFileExtension>$(DefaultSourceExtension)</OutputFileExtension>
            </ManagedPreprocessFile>
            <Clean Include="@(SplitTextStringResource->'$(IntermediateOutputDirectory)\%(Filename).SplitResourceClass.$(DefaultSourceExtension)pp')"
                   Condition="'%(SplitTextStringResource.FullClassName)' != '' and '%(SplitTextStringResource.NoStringResourcesClass)' != 'true'"/>
        </ItemGroup>

    </Target>
    <!-- ********************************************************************************************* -->

    <!-- ********************************************************************************************* -->
    <!-- *** Generate strongly parameterized Error and Strings classes -->
    <!-- ********************************************************************************************* -->
    <Target Name="GenerateSplitParameterizedResourceClasses"
            Inputs="$(MSBuildAllProjects);@(SplitTextStringResource)"
            Outputs="@(SplitTextStringResource->'%(RootDir)%(Directory)Parameterized.%(Filename).cs')"
            DependsOnTargets="$(GenerateParameterizedResourceClassesDependsOn)"
            Condition="'@(SplitTextStringResource)' != ''">

        <Exec 
          Command="perl -w $(DevDivToolsPath)\genstr.pl @(SplitTextStringResource) %(SplitTextStringResource.RootDir)%(SplitTextStringResource.Directory)Parameterized.%(SplitTextStringResource.Filename).cs %(SplitTextStringResource.ResFile) %(SplitTextStringResource.FullClassName) -D %(SplitTextStringResource.GenSRDefines) INCLUDE_RUNTIME INCLUDE_DEBUG"
          StandardOutputImportance="Normal"
          Condition="'%(SplitTextStringResource.Parameterize)'=='true'"
        />        

    </Target>

    <!-- ********************************************************************************************* -->
    <!-- *** Verify security transparency annotations -->
    <!-- ********************************************************************************************* -->
    <PropertyGroup>
        <SecAnnotateCommand Condition="'$(SecAnnotateCommand)' == ''">$(ManagedToolsRoot)v4.5\SecAnnotate.exe</SecAnnotateCommand>
        <SecAnnotateInput Condition="'$(SecAnnotateInput)' == ''">$(IntermediateOutputPath)$(TargetName)$(TargetExt)</SecAnnotateInput>
        <SecAnnotateLog Condition="'$(SecAnnotateLog)' == ''">$(IntermediateOutputPath)$(TargetName).TransparencyAnnotations.xml</SecAnnotateLog>
    </PropertyGroup>
    <Target Name="VerifySecurityAnnotations"
            Inputs="$(SecAnnotateInput)"
            Outputs="$(SecAnnotateLog)"
            Condition="'$(VerifySecurityAnnotations)' == 'true'" 
            AfterTargets="Compile">

        <Exec Command="$(SecAnnotateCommand) $(SecAnnotateInput) $(SecAnnotateOptions) /d:$(ClrRefPath) /d:$(NDP_FXRefPath) /d:$(WinSdkRefPath) /o:$(SecAnnotateLog)" StandardOutputImportance="Normal" />    
    </Target>

    <!-- ********************************************************************************************* -->


    <!-- ********************************************************************************************* -->
    <!-- *** Verify Api Conformance between SKUs                                                       -->
    <!-- ********************************************************************************************* -->

    <UsingTask TaskName="Microsoft.Build.InternalTasks.ApiConformance" AssemblyFile="$(ApiConformanceRootDirectory)\ApiConformance.exe" />

    <Target Name="VerifyApiConformance" AfterTargets="Compile" Condition="'$(BuildType)' == 'Retail' and '$(VerifyApiConformance)' == 'true' and '$(BuildForCoreSystem)' != 'true'" >
        <ApiConformance Assembly="@(IntermediateAssembly)" AssemblyDependencyPaths="$(ClrRefPath);$(EnvRefPath);$(PlatformRefPath);$(SdkRefPath);$(NDP_FXRefPath);$(AdpRefPath);$(WinFxInternalRefPath);$(WinFxExternalRefPath);$(WinFxRefPath);$(VBRefPath);$(WPFRefPath)" BuildType="$(ApiConformanceBuildType)" BuildVersion="$(ApiConformanceBuildVersion)" ConformityRoot="$(ApiConformanceRootDirectory)" BaselineRoot="$(ApiConformanceBaselineDirectory)" />
    </Target>


    <!-- ********************************************************************************************* -->
 
    <!-- ********************************************************************************************* -->
    <!-- *** Enable the LocalAppContext switching infrastructure                                       -->
    <!-- ********************************************************************************************* -->
 
    <!-- Notes:
         We are going to include the LocalAppContext.cs and AppContextDefaultValues.cs for all platforms since they
           provide the fallback for calling into the central AppContext.
         The .Defaults.*.cs files are only included for desktop because we don't have access to read the TFM off the 
           AppDomain class in CoreClr
    -->
  
    <ItemGroup Condition="'$(EnableLocalAppContext)'=='true'">
      <Compile Include="$(CLRIncPath)\LocalAppContext.cs" >
        <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
      </Compile>
      <Compile Include="$(CLRIncPath)\AppContextDefaultValues.cs" >
        <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
      </Compile>
    </ItemGroup>
  
    <!-- ********************************************************************************************* -->


    <PropertyGroup>
        <OutputRootPath Condition="'$(OutputRootPath)'==''">$(_NTTree)</OutputRootPath>
    </PropertyGroup>
    
    <!-- The below libraries should only be set if this is a CoreSys build as they only come from there -->
    <PropertyGroup Condition="'$(BuildProjectName)'!='CoreSys'">
        <IsProjectKLibrary>false</IsProjectKLibrary>
        <IsTestNetLibrary>false</IsTestNetLibrary>
        <IsTestNetCoreRuntimeLibrary>false</IsTestNetCoreRuntimeLibrary>
        <IsPhoneLibrary>false</IsPhoneLibrary>
        <OneCoreToolsPath></OneCoreToolsPath>
    </PropertyGroup>
    <Import Project="$(_NTDRIVE)$(_NTROOT)\InternalAPIs\NDP_Common\Inc\ProductFile.targets" />

</Project>
